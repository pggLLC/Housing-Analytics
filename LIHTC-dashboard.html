<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LIHTC Allocations Dashboard | Affordable Housing Intelligence</title>
  <meta name="description" content="Interactive LIHTC state allocation maps and analysis.">
    <script src="js/path-resolver.js"></script>
  <script src="js/config.js"></script>
  <script src="js/fetch-helper.js"></script>
  <script src="js/data-service-portable.js"></script>
  <script src="js/scroll-fix.js"></script>
<script src="js/vendor/d3.v7.min.js"></script>
  <script src="js/vendor/topojson.v3.min.js"></script>
  <script src="js/state-allocations-2026.js"></script>
  <script src="js/state-allocations-2025.js"></script>
  <script src="js/state-allocations-2024.js"></script>
  <link rel="stylesheet" href="css/site-theme.css">
  <link rel="stylesheet" href="css/layout.css">
  <link rel="stylesheet" href="css/pages.css">
  
  <script defer src="js/navigation.js"></script>
  <script defer src="js/dark-mode-toggle.js"></script>
  <script defer src="js/mobile-menu.js"></script>
</head>
<body>
<div id="statusPanel" aria-live="polite"></div>
<a class="skip-link" href="#main-content">Skip to main content</a>
<main id="main-content" class="page-container content-shell">
<section class="hero">
<h1>LIHTC Allocations</h1>
<p>One-page workspace combining the Dashboard, Regional Analysis, and State Allocation Map. Each section runs the original page inside an embedded frame to keep all maps, tables, dropdowns, exports, and tooltips working without conflicts.</p>
<div class="sub">Distribution / allocation of LIHTC by region and state.</div>
</section>
<section class="card">
<h2>Filters</h2>
<div class="controls">
<div>
<label for="year-select">Year</label>
<select id="year-select">
<option selected="" value="2026">2026</option>
<option value="2025">2025</option>
<option value="2024">2024</option>
</select>
</div>
<div>
<label for="mode-select">Map mode</label>
<select id="mode-select">
<option selected="" value="region">Regional view</option>
<option value="allocation">State allocations (per-capita intensity)</option>
</select>
</div>
<div>
<label for="region-select">Region</label>
<select id="region-select">
<option selected="" value="all">All regions (National)</option>
<option value="northeast">Northeast</option>
<option value="south">South</option>
<option value="midwest">Midwest</option>
<option value="west">West</option>
</select>
</div>
<div>
<label for="state-select">State</label>
<select id="state-select">
<option selected="" value="all">All states</option>
</select>
</div>
<div style="grid-column: 1 / -1;">
<label for="state-search">Quick search</label>
<input id="state-search" placeholder="Type a state name or abbr (e.g., CO)"/>
</div>
</div>
<div class="statusbar">
<span class="pill" id="status-dataset">Dataset: —</span>
<span class="pill" id="status-loaded">Loaded: —</span>
</div>
<div class="stats">
<div class="stat">
<div class="k">Total allocation</div>
<div class="v" id="stat-total">$0</div>
</div>
<div class="stat">
<div class="k">Per-capita (weighted)</div>
<div class="v" id="stat-percap">$0</div>
</div>
<div class="stat">
<div class="k">States included</div>
<div class="v" id="stat-states">0</div>
</div>
<div class="stat">
<div class="k">% of national</div>
<div class="v" id="stat-share">0%</div>
</div>
</div>
</section>
<div id="map-section-outer">
  <div id="map-section-header">
    <h2>Interactive map</h2>
    <div class="muted small" style="margin-bottom:0;">Switch between regional coloring and state allocation intensity. Tooltips on hover.</div>
  </div>
  <div id="map-wrap">
    <div class="map-legend" id="map-legend"></div>
    <div class="tooltip" id="map-tooltip">
      <h4 id="tt-title"></h4>
      <div id="tt-body"></div>
    </div>
    <div id="us-map"></div>
  </div>
</div>
<section class="card">
<h2>Regional allocation summary</h2>
<div class="muted small">Totals and shares update when you select a year and region.</div>
<div class="tablewrap">
<table>
<thead>
<tr>
<th data-sort="region">Region</th>
<th class="right" data-sort="states">States</th>
<th class="right" data-sort="alloc">Total allocation</th>
<th class="right" data-sort="share">% of national</th>
<th class="right" data-sort="percap">Per-capita</th>
</tr>
</thead>
<tbody id="region-summary-body"></tbody>
</table>
</div>
<h2 style="margin-top:1.2rem;">Top 10 states (selection)</h2>
<div class="muted small">Top 10 by allocation within the selected region/state (or national if “All”).</div>
<div class="tablewrap">
<table>
<thead>
<tr>
<th>#</th>
<th data-sort="name">State</th>
<th data-sort="abbr">Abbr</th>
<th class="right" data-sort="allocation">Allocation</th>
<th class="right" data-sort="perCapita">Per-capita</th>
<th class="right" data-sort="share">% of national</th>
</tr>
</thead>
<tbody id="top10-body"></tbody>
</table>
</div>
</section>
<section class="card" style="margin-top:1.25rem;">
<h2>State table</h2>
<div class="muted small">Sortable. Filtered by year, region, state, and search. Shows up to 50 rows.</div>
<div class="tablewrap">
<table id="states-table">
<thead>
<tr>
<th data-sort="rank">#</th>
<th data-sort="name">State</th>
<th data-sort="abbr">Abbr</th>
<th class="right" data-sort="population">Population</th>
<th class="right" data-sort="allocation">Allocation</th>
<th class="right" data-sort="perCapita">Per-capita</th>
<th class="right" data-sort="share">% of national</th>
</tr>
</thead>
<tbody id="states-body"></tbody>
</table>
</div>
</section>
</main>
<script>
    const REGIONS = {
      northeast: ['CT','ME','MA','NH','RI','VT','NJ','NY','PA'],
      south: ['DE','FL','GA','MD','NC','SC','VA','DC','WV','AL','KY','MS','TN','AR','LA','OK','TX'],
      midwest: ['IL','IN','MI','OH','WI','IA','KS','MN','MO','NE','ND','SD'],
      west: ['AZ','CO','ID','MT','NV','NM','UT','WY','AK','CA','HI','OR','WA']
    };

    const regionColors = {
      northeast: '#7fb3d5',
      south: '#d4a574',
      midwest: '#82c29a',
      west: '#c08ad6',
      other: '#444'
    };

    const fipsToAbbr = {
      1:'AL',2:'AK',4:'AZ',5:'AR',6:'CA',8:'CO',9:'CT',10:'DE',11:'DC',12:'FL',13:'GA',15:'HI',16:'ID',17:'IL',18:'IN',19:'IA',20:'KS',21:'KY',22:'LA',23:'ME',24:'MD',25:'MA',26:'MI',27:'MN',28:'MS',29:'MO',30:'MT',31:'NE',32:'NV',33:'NH',34:'NJ',35:'NM',36:'NY',37:'NC',38:'ND',39:'OH',40:'OK',41:'OR',42:'PA',44:'RI',45:'SC',46:'SD',47:'TN',48:'TX',49:'UT',50:'VT',51:'VA',53:'WA',54:'WV',55:'WI',56:'WY'
    };

    const els = {
      year: document.getElementById('year-select'),
      mode: document.getElementById('mode-select'),
      region: document.getElementById('region-select'),
      state: document.getElementById('state-select'),
      search: document.getElementById('state-search'),
      statTotal: document.getElementById('stat-total'),
      statPerCap: document.getElementById('stat-percap'),
      statStates: document.getElementById('stat-states'),
      statShare: document.getElementById('stat-share'),
      legend: document.getElementById('map-legend'),
      tooltip: document.getElementById('map-tooltip'),
      ttTitle: document.getElementById('tt-title'),
      ttBody: document.getElementById('tt-body'),
      regionSummaryBody: document.getElementById('region-summary-body'),
      top10Body: document.getElementById('top10-body'),
      statesBody: document.getElementById('states-body'),
      statusDataset: document.getElementById('status-dataset'),
      statusLoaded: document.getElementById('status-loaded'),
      statesTable: document.getElementById('states-table'),
    };

// --- Dynamic state list (single source of truth) ---
    let STATE_META = null;     // Array<{abbr,name,region}>
    let REGIONS_META = null;   // { region: Set<abbr> }

    async function loadAllocationsMeta(){
      try{
        const data = await DataService.getJSON(DataService.baseData("allocations.json"));
        const statesObj = data && data.states ? data.states : {};
        const list = Object.values(statesObj).map(s => ({
          abbr: s.abbr || s.code || "",
          name: s.name || "",
          region: (s.region || "").toLowerCase()
        })).filter(s => s.abbr && s.name);
        STATE_META = list.sort((a,b)=>a.name.localeCompare(b.name));

        REGIONS_META = {};
        for (const s of STATE_META){
          if (!REGIONS_META[s.region]) REGIONS_META[s.region] = new Set();
          REGIONS_META[s.region].add(s.abbr);
        }
        return true;
      }catch(err){
        console.warn("Allocations meta unavailable; falling back to dataset-derived states.", err);
        return false;
      }
    }

    function getAllowedStatesForRegion(region){
      if (region && region !== "all"){
        // Prefer allocations.json region mapping; fallback to hardcoded REGIONS.
        if (REGIONS_META && REGIONS_META[region]) return REGIONS_META[region];
        return new Set(REGIONS[region] || []);
      }
      // all regions
      if (STATE_META) return new Set(STATE_META.map(s=>s.abbr));
      return null;
    }

    function populateStateSelectFromMeta(region){
      if (!STATE_META) return false;
      const allowed = getAllowedStatesForRegion(region);
      els.state.innerHTML = '<option value="all" selected>All states</option>';
      for (const s of STATE_META){
        if (allowed && !allowed.has(s.abbr)) continue;
        const opt = document.createElement('option');
        opt.value = s.abbr;
        opt.textContent = s.name;
        els.state.appendChild(opt);
      }
      return true;
    }


    function fmtShortMoney(n){
      n = Number(n)||0;
      if (n >= 1e9) return '$' + (n/1e9).toFixed(2) + 'B';
      if (n >= 1e6) return '$' + (n/1e6).toFixed(1) + 'M';
      return '$' + n.toLocaleString();
    }
    function fmtNum(n, d=2){ return (Number(n)||0).toFixed(d); }

    function getDatasetForYear(year){
      if (year === '2026') return window.StateAllocations2026;
      if (year === '2025') return window.StateAllocations2025;
      if (year === '2024') return window.StateAllocations2024;
      return window.StateAllocations2026;
    }

    function getAllStates(dataset){
      if (!dataset?.states) return [];
      return Object.entries(dataset.states).map(([abbr, s]) => ({ abbr, ...s }));
    }

    function getRegionOfState(abbr){
      for (const [r, list] of Object.entries(REGIONS)){
        if (list.includes(abbr)) return r;
      }
      return 'other';
    }

    function populateStateSelect(dataset, region){
      // Prefer allocations.json for a stable, single source of truth
      if (populateStateSelectFromMeta(region || els.region.value)) return;

      // Fallback: derive from embedded year dataset
      const all = getAllStates(dataset).sort((a,b)=>a.name.localeCompare(b.name));
      const allowed = (region && region !== "all") ? new Set(REGIONS[region] || []) : null;
      els.state.innerHTML = '<option value="all" selected>All states</option>';
      for (const s of all){
        if (allowed && !allowed.has(s.abbr)) continue;
        const opt = document.createElement('option');
        opt.value = s.abbr;
        opt.textContent = s.name;
        els.state.appendChild(opt);
      }
    }

    function applyFilters(dataset){
      const all = getAllStates(dataset);
      const region = els.region.value;
      const state = els.state.value;
      const q = (els.search.value || '').trim().toLowerCase();

      let scoped = all;

      if (region !== 'all'){
        const allowed = new Set(REGIONS[region] || []);
        scoped = scoped.filter(s => allowed.has(s.abbr));
      }

      if (state !== 'all'){
        scoped = scoped.filter(s => s.abbr === state);
      }

      if (q){
        scoped = scoped.filter(s =>
          (s.name || '').toLowerCase().includes(q) ||
          (s.abbr || '').toLowerCase() === q
        );
      }

      return { all, scoped, region, state, q };
    }

    // ---------- MAP ----------
    let usTopo = null;
    let svg = null;
    let pathGen = null;
    let lastSort = { key: 'allocation', dir: 'desc' };

    function ensureMap(){
      const container = document.getElementById('us-map');
      container.innerHTML = '';

      // Use offsetWidth (reliable at DOMContentLoaded); compute height by AlbersUSA aspect ~1.62:1
      const width  = container.offsetWidth || container.parentElement?.offsetWidth || 960;
      // Use a fixed logical height for the projection — CSS will scale SVG to fill the container
      // AlbersUSA fits nicely in a 960×600 logical space
      const logicalH = Math.round(width / 1.6);

      svg = d3.select(container).append('svg')
        .attr('width', width)
        .attr('height', logicalH)
        .attr('viewBox', `0 0 ${width} ${logicalH}`)
        .attr('preserveAspectRatio', 'xMidYMid meet')
        .style('display', 'block')
        .style('width', '100%')
        .style('height', '100%');

      if (!usTopo) return;

      const features = topojson.feature(usTopo, usTopo.objects.states).features;
      const projection = d3.geoAlbersUsa().fitSize([width, logicalH], {type:'FeatureCollection', features});
      pathGen = d3.geoPath(projection);

      svg.append('g').attr('id','states-layer');

      svg.append('path')
        .datum(topojson.mesh(usTopo, usTopo.objects.states, (a,b)=>a!==b))
        .attr('fill','none')
        .attr('stroke','rgba(255,255,255,0.35)')
        .attr('stroke-width',0.65)
        .attr('d', pathGen);
    }

    function showTip(evt, title, html){
      const wrap = document.getElementById('map-wrap');
      const rect = wrap.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;

      els.ttTitle.textContent = title;
      els.ttBody.innerHTML = html;

      // keep inside container
      const pad = 12;
      els.tooltip.style.left = Math.min(x + pad, rect.width - 300) + 'px';
      els.tooltip.style.top = Math.min(y + pad, rect.height - 140) + 'px';
      els.tooltip.classList.add('visible');
    }
    function hideTip(){ els.tooltip.classList.remove('visible'); }

    function renderLegend(mode, bins){
      if (mode === 'region'){
        els.legend.innerHTML = `
          <div class="legend-title">Map Legend (Regions)</div>
          ${['northeast','south','midwest','west'].map(r => `
            <div class="legend-item">
              <span class="legend-color" style="background:${regionColors[r]}"></span>
              <span>${r.charAt(0).toUpperCase()+r.slice(1)}</span>
            </div>
          `).join('')}
        `;
        return;
      }

      const rows = (bins || []).map(b => `
        <div class="legend-item">
          <span class="legend-color" style="background:${b.color}"></span>
          <span>${b.label}</span>
        </div>
      `).join('');

      const hasFilter = els.region.value !== 'all' || els.state.value !== 'all' || els.search.value.trim();
      const notSelectedRow = hasFilter ? `
        <div class="legend-item" style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border);">
          <span class="legend-color" style="background:rgba(120,120,130,0.35); border-style:dashed;"></span>
          <span style="color:var(--faint)">Not selected</span>
        </div>` : '';

      els.legend.innerHTML = `
        <div class="legend-title">Map Legend (Per-capita intensity)</div>
        ${rows}
        ${notSelectedRow}
      `;
    }

    function computeBins(values){
      const v = values.filter(x => isFinite(x) && x >= 0).sort((a,b)=>a-b);
      if (!v.length){
        return { scale: ()=>'#444', bins: [{color:'#444', label:'No data'}] };
      }

      // Use 5 quantile thresholds so every state in a band gets the exact
      // same discrete colour shown in the legend swatch.
      const N = 5;
      const q = (p) => v[Math.min(v.length - 1, Math.floor((v.length) * p))];
      const thresholds = [];
      for (let i = 1; i < N; i++) thresholds.push(q(i / N));

      // Five evenly-spaced Blues palette stops (light → dark)
      const palette = ['#c6dbef','#9ecae1','#6baed6','#3182bd','#08519c'];

      const scale = d3.scaleThreshold()
        .domain(thresholds)
        .range(palette);

      // Build legend bins: show the actual [lo, hi) range for each band
      const cuts = [v[0], ...thresholds, v[v.length - 1]];
      const bins = palette.map((color, i) => ({
        color,
        label: i < N - 1
          ? `$${fmtNum(cuts[i], 2)} – $${fmtNum(cuts[i + 1], 2)}`
          : `$${fmtNum(cuts[i], 2)}+`
      }));

      return { scale, bins };
    }

    function updateMap(dataset){
      if (!usTopo || !svg || !pathGen) return;

      const { all, scoped } = applyFilters(dataset);
      const mode = els.mode.value;
      const statesByAbbr = dataset?.states || {};
      const allowed = new Set(scoped.map(s => s.abbr));

      let scale = null;
      let bins = null;
      if (mode === 'allocation'){
        const perCaps = scoped.map(s => Number(s.perCapita)||0);
        const b = computeBins(perCaps);
        scale = b.scale;
        bins = b.bins;
      }
      renderLegend(mode, bins);

      const features = topojson.feature(usTopo, usTopo.objects.states).features;
      const layer = svg.select('#states-layer');
      layer.selectAll('path').remove();

      layer.selectAll('path')
        .data(features)
        .join('path')
        .attr('d', pathGen)
        .attr('stroke', 'rgba(255,255,255,0.55)')
        .attr('stroke-width', 0.85)
        .attr('fill', d => {
          const abbr = fipsToAbbr[Number(d.id)];
          const s = abbr ? statesByAbbr[abbr] : null;
          if (!s) return '#2a2a2a';
          const inScope = allowed.has(abbr);
          if (mode === 'region'){
            const r = getRegionOfState(abbr);
            const c = regionColors[r] || regionColors.other;
            return inScope ? c : 'rgba(120,120,130,0.35)';
          } else {
            const pc = Number(s.perCapita)||0;
            const c = scale ? scale(pc) : '#2a2a2a';
            return inScope ? c : 'rgba(120,120,130,0.35)';
          }
        })
        .on('mousemove', (event, d) => {
          const abbr = fipsToAbbr[Number(d.id)];
          const s = abbr ? statesByAbbr[abbr] : null;
          if (!s) return;

          const nationalTotal = all.reduce((sum,x)=>sum+(Number(x.allocation)||0),0);
          const pct = nationalTotal ? (Number(s.allocation||0)/nationalTotal*100) : 0;
          const r = getRegionOfState(abbr);

          showTip(event, `${s.name} (${abbr})`,
            `<div><strong>Region:</strong> ${r.charAt(0).toUpperCase()+r.slice(1)}</div>
             <div><strong>Total allocation:</strong> ${fmtShortMoney(s.allocation||0)}</div>
             <div><strong>Per-capita:</strong> $${fmtNum(s.perCapita||0,2)}</div>
             <div><strong>% of national:</strong> ${fmtNum(pct,2)}%</div>`
          );
        })
        .on('mouseleave', hideTip);
    }

    // ---------- TABLES / STATS ----------
    function updateStatsAndTables(dataset){
      const { all, scoped, region } = applyFilters(dataset);
      const nationalTotal = all.reduce((sum,s)=>sum+(Number(s.allocation)||0),0);
      const totalAlloc = scoped.reduce((sum,s)=>sum+(Number(s.allocation)||0),0);
      const totalPop = scoped.reduce((sum,s)=>sum+(Number(s.population)||0),0);
      const share = nationalTotal ? (totalAlloc/nationalTotal*100) : 0;
      const perCapWeighted = totalAlloc / (totalPop || 1);

      els.statTotal.textContent = fmtShortMoney(totalAlloc);
      els.statPerCap.textContent = '$' + fmtNum(perCapWeighted, 2);
      els.statStates.textContent = String(scoped.length);
      els.statShare.textContent = fmtNum(share, 1) + '%';

      // Region summary
      const regions = ['northeast','south','midwest','west'];
      const byRegion = regions.map(r => {
        const set = new Set(REGIONS[r]);
        const rs = all.filter(s => set.has(s.abbr));
        const rAlloc = rs.reduce((sum,s)=>sum+(Number(s.allocation)||0),0);
        const rPop = rs.reduce((sum,s)=>sum+(Number(s.population)||0),0);
        return {
          region: r,
          states: rs.length,
          alloc: rAlloc,
          share: nationalTotal ? (rAlloc/nationalTotal*100) : 0,
          percap: rAlloc/(rPop||1)
        };
      });

      els.regionSummaryBody.innerHTML = byRegion.map(r => {
        const isSel = (region === r.region);
        return `
          <tr style="${isSel ? 'background: rgba(212,165,116,0.12);' : ''}">
            <td><strong>${r.region.charAt(0).toUpperCase()+r.region.slice(1)}</strong></td>
            <td class="right">${r.states}</td>
            <td class="right">${fmtShortMoney(r.alloc)}</td>
            <td class="right">${fmtNum(r.share,1)}%</td>
            <td class="right">$${fmtNum(r.percap,2)}</td>
          </tr>
        `;
      }).join('');

      // Top 10 in selection
      const top10 = [...scoped].sort((a,b)=>b.allocation-a.allocation).slice(0,10);
      els.top10Body.innerHTML = top10.map((s,i) => `
        <tr>
          <td>${i+1}</td>
          <td><strong>${s.name}</strong></td>
          <td>${s.abbr}</td>
          <td class="right">${fmtShortMoney(s.allocation)}</td>
          <td class="right">$${fmtNum(s.perCapita,2)}</td>
          <td class="right">${fmtNum((s.allocation/nationalTotal)*100,2)}%</td>
        </tr>
      `).join('');

      // State table with sorting
      const tableRows = [...scoped];
      const sortKey = lastSort.key;
      const dir = lastSort.dir;

      tableRows.sort((a,b) => {
        const av = (sortKey === 'name' || sortKey === 'abbr') ? String(a[sortKey]||'') : Number(a[sortKey]||0);
        const bv = (sortKey === 'name' || sortKey === 'abbr') ? String(b[sortKey]||'') : Number(b[sortKey]||0);
        if (sortKey === 'name' || sortKey === 'abbr') {
          return dir === 'asc' ? av.localeCompare(bv) : bv.localeCompare(av);
        }
        return dir === 'asc' ? (av - bv) : (bv - av);
      });

      const rows = tableRows.slice(0,50);
      els.statesBody.innerHTML = rows.map((s,i) => `
        <tr>
          <td>${i+1}</td>
          <td><strong>${s.name}</strong></td>
          <td>${s.abbr}</td>
          <td class="right">${Number(s.population||0).toLocaleString()}</td>
          <td class="right">${fmtShortMoney(s.allocation)}</td>
          <td class="right">$${fmtNum(s.perCapita,2)}</td>
          <td class="right">${fmtNum((s.allocation/nationalTotal)*100,2)}%</td>
        </tr>
      `).join('');
    }

    function wireSorting(){
      const ths = els.statesTable.querySelectorAll('thead th[data-sort]');
      ths.forEach(th => {
        th.addEventListener('click', () => {
          const key = th.getAttribute('data-sort');
          // map header keys to dataset fields
          const map = { population:'population', allocation:'allocation', perCapita:'perCapita', name:'name', abbr:'abbr' };
          const newKey = map[key] || key;

          if (lastSort.key === newKey){
            lastSort.dir = lastSort.dir === 'asc' ? 'desc' : 'asc';
          } else {
            lastSort.key = newKey;
            lastSort.dir = (newKey === 'name' || newKey === 'abbr') ? 'asc' : 'desc';
          }

          // update indicators
          ths.forEach(x => x.classList.remove('sort-asc','sort-desc'));
          th.classList.add(lastSort.dir === 'asc' ? 'sort-asc' : 'sort-desc');

          rerender();
        });
      });

      // default sort indicator on Allocation
      const allocTh = els.statesTable.querySelector('thead th[data-sort="allocation"]');
      if (allocTh) allocTh.classList.add('sort-desc');
    }

    // ---------- RENDER LOOP ----------
    function setStatus(dataset){
      const year = els.year.value;
      els.statusDataset.textContent = `Dataset: Novogradac ${year}`;
      const ok = dataset && dataset.states && Object.keys(dataset.states).length > 0;
      els.statusLoaded.innerHTML = ok ? `Loaded: <span class="ok">✅</span>` : `Loaded: <span class="bad">❌</span>`;
    }

    let rerender = () => {};

    async function init(){
      // Load topo once — local copy first (no CDN required), GitHub Pages backup, then CDN as final fallback
      try {
        usTopo = await d3.json('data/states-10m.json');
      } catch(e) {
        console.warn('Local topology not found, trying GitHub Pages backup:', e.message);
        try {
          usTopo = await d3.json('https://pggllc.github.io/Housing-Analytics/data/states-10m.json');
        } catch(e2) {
          console.warn('GitHub Pages topology backup unavailable, trying CDN:', e2.message);
          try {
            usTopo = await d3.json('https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json');
          } catch(e3) {
            console.error('Failed to load US topojson', e3);
          }
        }
      }
      ensureMap();

      wireSorting();

      rerender = () => {
        const dataset = getDatasetForYear(els.year.value);
        setStatus(dataset);
        if (!dataset?.states) return;

        // keep state select in sync with year (same state list but safe)
        if (!els.state.__populatedForYear || els.state.__populatedForYear !== els.year.value) {
          // Populate with region restriction so the dropdown stays consistent.
          populateStateSelect(dataset, els.region.value);
          els.state.__populatedForYear = els.year.value;
          els.state.value = 'all';
        }

        updateStatsAndTables(dataset);
        updateMap(dataset);
      };

      // Events
      els.year.addEventListener('change', () => {
        // clear filters to avoid empty due to alias mismatch
        els.region.value = 'all';
        els.state.value = 'all';
        els.search.value = '';
        rerender();
      });
      els.mode.addEventListener('change', () => rerender());
      els.region.addEventListener('change', () => {
        // When a region is selected, restrict the state dropdown to states in that region.
        const dataset = getDatasetForYear(els.year.value);
        populateStateSelect(dataset, els.region.value);
        // reset state selection when region changes for clarity
        els.state.value = 'all';
        rerender();
      });
      els.state.addEventListener('change', () => {
        // clear search when explicit state chosen
        if (els.state.value !== 'all') els.search.value = '';
        rerender();
      });

      els.search.addEventListener('input', () => {
        // if searching, reset explicit state
        els.state.value = 'all';
        clearTimeout(window.__qTimer);
        window.__qTimer = setTimeout(() => rerender(), 160);
      });

      window.addEventListener('resize', () => {
        clearTimeout(window.__rTimer);
        window.__rTimer = setTimeout(() => {
          ensureMap();
          const dataset = getDatasetForYear(els.year.value);
          updateMap(dataset);
        }, 140);
      });

      // initial
      rerender();
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
<script src="js/contrast-guard.js"></script>

<!-- Region → State restriction is handled in the main init() logic above. -->

</body>
</html>
